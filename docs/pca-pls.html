<!DOCTYPE html>
<html lang="es" xml:lang="es">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>6.2 Métodos de reducción de la dimensión | Métodos predictivos de aprendizaje estadístico</title>
  <meta name="description" content="6.2 Métodos de reducción de la dimensión | Métodos predictivos de aprendizaje estadístico con R." />
  <meta name="generator" content="bookdown 0.36 and GitBook 2.6.7" />

  <meta property="og:title" content="6.2 Métodos de reducción de la dimensión | Métodos predictivos de aprendizaje estadístico" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="6.2 Métodos de reducción de la dimensión | Métodos predictivos de aprendizaje estadístico con R." />
  <meta name="github-repo" content="rubenfcasal/book_mpae" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="6.2 Métodos de reducción de la dimensión | Métodos predictivos de aprendizaje estadístico" />
  
  <meta name="twitter:description" content="6.2 Métodos de reducción de la dimensión | Métodos predictivos de aprendizaje estadístico con R." />
  

<meta name="author" content="Rubén Fernández Casal (ruben.fcasal@udc.es)" />
<meta name="author" content="Julián Costa Bouzas (julian.costa@udc.es)" />
<meta name="author" content="Manuel Oviedo de la Fuente (manuel.oviedo@udc.es)" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="shrinkage.html"/>
<link rel="next" href="reg-np.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>
<script src="libs/htmlwidgets-1.6.2/htmlwidgets.js"></script>
<link href="libs/datatables-css-0.0.0/datatables-crosstalk.css" rel="stylesheet" />
<script src="libs/datatables-binding-0.30/datatables.js"></script>
<link href="libs/dt-core-1.13.4/css/jquery.dataTables.min.css" rel="stylesheet" />
<link href="libs/dt-core-1.13.4/css/jquery.dataTables.extra.css" rel="stylesheet" />
<script src="libs/dt-core-1.13.4/js/jquery.dataTables.min.js"></script>
<link href="libs/crosstalk-1.2.0/css/crosstalk.min.css" rel="stylesheet" />
<script src="libs/crosstalk-1.2.0/js/crosstalk.min.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>
<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Métodos predictivos de aprendizaje estadístico</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Bienvenida</a></li>
<li class="chapter" data-level="" data-path="prólogo.html"><a href="prólogo.html"><i class="fa fa-check"></i>Prólogo</a>
<ul>
<li class="chapter" data-level="" data-path="el-lenguaje-de-programación-r.html"><a href="el-lenguaje-de-programación-r.html"><i class="fa fa-check"></i>El lenguaje de programación R</a></li>
<li class="chapter" data-level="" data-path="organización.html"><a href="organización.html"><i class="fa fa-check"></i>Organización</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="intro-AE.html"><a href="intro-AE.html"><i class="fa fa-check"></i><b>1</b> Introducción al aprendizaje estadístico</a>
<ul>
<li class="chapter" data-level="1.1" data-path="aprendizaje-estadístico-vs.-aprendizaje-automático.html"><a href="aprendizaje-estadístico-vs.-aprendizaje-automático.html"><i class="fa fa-check"></i><b>1.1</b> Aprendizaje estadístico vs. aprendizaje automático</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="aprendizaje-estadístico-vs.-aprendizaje-automático.html"><a href="aprendizaje-estadístico-vs.-aprendizaje-automático.html#las-dos-culturas"><i class="fa fa-check"></i><b>1.1.1</b> Las dos culturas</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="métodos-de-aprendizaje-estadístico.html"><a href="métodos-de-aprendizaje-estadístico.html"><i class="fa fa-check"></i><b>1.2</b> Métodos de aprendizaje estadístico</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="métodos-de-aprendizaje-estadístico.html"><a href="métodos-de-aprendizaje-estadístico.html#notacion"><i class="fa fa-check"></i><b>1.2.1</b> Notación y terminología</a></li>
<li class="chapter" data-level="1.2.2" data-path="métodos-de-aprendizaje-estadístico.html"><a href="métodos-de-aprendizaje-estadístico.html#metodos-pkgs"><i class="fa fa-check"></i><b>1.2.2</b> Métodos (de aprendizaje supervisado) y paquetes de R</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="const-eval.html"><a href="const-eval.html"><i class="fa fa-check"></i><b>1.3</b> Construcción y evaluación de los modelos</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="const-eval.html"><a href="const-eval.html#bias-variance"><i class="fa fa-check"></i><b>1.3.1</b> Equilibrio entre sesgo y varianza: infraajuste y sobreajuste</a></li>
<li class="chapter" data-level="1.3.2" data-path="const-eval.html"><a href="const-eval.html#entrenamiento-test"><i class="fa fa-check"></i><b>1.3.2</b> Datos de entrenamiento y datos de test</a></li>
<li class="chapter" data-level="1.3.3" data-path="const-eval.html"><a href="const-eval.html#cv"><i class="fa fa-check"></i><b>1.3.3</b> Selección de hiperparámetros mediante validación cruzada</a></li>
<li class="chapter" data-level="1.3.4" data-path="const-eval.html"><a href="const-eval.html#eval-reg"><i class="fa fa-check"></i><b>1.3.4</b> Evaluación de un método de regresión</a></li>
<li class="chapter" data-level="1.3.5" data-path="const-eval.html"><a href="const-eval.html#eval-class"><i class="fa fa-check"></i><b>1.3.5</b> Evaluación de un método de clasificación</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="dimen-curse.html"><a href="dimen-curse.html"><i class="fa fa-check"></i><b>1.4</b> La maldición de la dimensionalidad</a></li>
<li class="chapter" data-level="1.5" data-path="analisis-modelos.html"><a href="analisis-modelos.html"><i class="fa fa-check"></i><b>1.5</b> Análisis e interpretación de los modelos</a></li>
<li class="chapter" data-level="1.6" data-path="caret.html"><a href="caret.html"><i class="fa fa-check"></i><b>1.6</b> Introducción al paquete <code>caret</code></a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="clasicos.html"><a href="clasicos.html"><i class="fa fa-check"></i><b>2</b> Métodos clásicos de estadística</a>
<ul>
<li class="chapter" data-level="2.1" data-path="rlm.html"><a href="rlm.html"><i class="fa fa-check"></i><b>2.1</b> Regresión lineal múltiple</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="rlm.html"><a href="rlm.html#colinealidad"><i class="fa fa-check"></i><b>2.1.1</b> El problema de la colinealidad</a></li>
<li class="chapter" data-level="2.1.2" data-path="rlm.html"><a href="rlm.html#seleccion-rlm"><i class="fa fa-check"></i><b>2.1.2</b> Selección de variables explicativas</a></li>
<li class="chapter" data-level="2.1.3" data-path="rlm.html"><a href="rlm.html#analisis-rlm"><i class="fa fa-check"></i><b>2.1.3</b> Análisis e interpretación del modelo</a></li>
<li class="chapter" data-level="2.1.4" data-path="rlm.html"><a href="rlm.html#eval-rlm"><i class="fa fa-check"></i><b>2.1.4</b> Evaluación de la precisión</a></li>
<li class="chapter" data-level="2.1.5" data-path="rlm.html"><a href="rlm.html#selec-ae-rlm"><i class="fa fa-check"></i><b>2.1.5</b> Selección del modelo mediante remuestreo</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="reg-glm.html"><a href="reg-glm.html"><i class="fa fa-check"></i><b>2.2</b> Modelos lineales generalizados</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="reg-glm.html"><a href="reg-glm.html#seleccion-glm"><i class="fa fa-check"></i><b>2.2.1</b> Selección de variables explicativas</a></li>
<li class="chapter" data-level="2.2.2" data-path="reg-glm.html"><a href="reg-glm.html#analisis-glm"><i class="fa fa-check"></i><b>2.2.2</b> Análisis e interpretación del modelo</a></li>
<li class="chapter" data-level="2.2.3" data-path="reg-glm.html"><a href="reg-glm.html#glm-bfan"><i class="fa fa-check"></i><b>2.2.3</b> Evaluación de la precisión</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="generadores.html"><a href="generadores.html"><i class="fa fa-check"></i><b>2.3</b> Otros métodos de clasificación</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="generadores.html"><a href="generadores.html#clas-lda"><i class="fa fa-check"></i><b>2.3.1</b> Análisis discriminante lineal</a></li>
<li class="chapter" data-level="2.3.2" data-path="generadores.html"><a href="generadores.html#clas-qda"><i class="fa fa-check"></i><b>2.3.2</b> Análisis discriminante cuadrático</a></li>
<li class="chapter" data-level="2.3.3" data-path="generadores.html"><a href="generadores.html#bayes"><i class="fa fa-check"></i><b>2.3.3</b> Bayes naíf</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="trees.html"><a href="trees.html"><i class="fa fa-check"></i><b>3</b> Árboles de decisión</a>
<ul>
<li class="chapter" data-level="3.1" data-path="árboles-de-regresión-cart.html"><a href="árboles-de-regresión-cart.html"><i class="fa fa-check"></i><b>3.1</b> Árboles de regresión CART</a></li>
<li class="chapter" data-level="3.2" data-path="árboles-de-clasificación-cart.html"><a href="árboles-de-clasificación-cart.html"><i class="fa fa-check"></i><b>3.2</b> Árboles de clasificación CART</a></li>
<li class="chapter" data-level="3.3" data-path="tree-rpart.html"><a href="tree-rpart.html"><i class="fa fa-check"></i><b>3.3</b> CART con el paquete <code>rpart</code></a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="tree-rpart.html"><a href="tree-rpart.html#reg-rpart"><i class="fa fa-check"></i><b>3.3.1</b> Ejemplo: regresión</a></li>
<li class="chapter" data-level="3.3.2" data-path="tree-rpart.html"><a href="tree-rpart.html#class-rpart"><i class="fa fa-check"></i><b>3.3.2</b> Ejemplo: modelo de clasificación</a></li>
<li class="chapter" data-level="3.3.3" data-path="tree-rpart.html"><a href="tree-rpart.html#interfaz-de-caret"><i class="fa fa-check"></i><b>3.3.3</b> Interfaz de <code>caret</code></a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="alternativas-a-los-árboles-cart.html"><a href="alternativas-a-los-árboles-cart.html"><i class="fa fa-check"></i><b>3.4</b> Alternativas a los árboles CART</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="bagging-boosting.html"><a href="bagging-boosting.html"><i class="fa fa-check"></i><b>4</b> Bagging y boosting</a>
<ul>
<li class="chapter" data-level="4.1" data-path="bagging.html"><a href="bagging.html"><i class="fa fa-check"></i><b>4.1</b> Bagging</a></li>
<li class="chapter" data-level="4.2" data-path="rf.html"><a href="rf.html"><i class="fa fa-check"></i><b>4.2</b> Bosques aleatorios</a></li>
<li class="chapter" data-level="4.3" data-path="bagging-rf-r.html"><a href="bagging-rf-r.html"><i class="fa fa-check"></i><b>4.3</b> Bagging y bosques aleatorios en R</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="bagging-rf-r.html"><a href="bagging-rf-r.html#ejemplo-clasificación-con-bagging"><i class="fa fa-check"></i><b>4.3.1</b> Ejemplo: clasificación con bagging</a></li>
<li class="chapter" data-level="4.3.2" data-path="bagging-rf-r.html"><a href="bagging-rf-r.html#ejemplo-clasif-rf"><i class="fa fa-check"></i><b>4.3.2</b> Ejemplo: clasificación con bosques aleatorios</a></li>
<li class="chapter" data-level="4.3.3" data-path="bagging-rf-r.html"><a href="bagging-rf-r.html#ejemplo-bosques-aleatorios-con-caret"><i class="fa fa-check"></i><b>4.3.3</b> Ejemplo: bosques aleatorios con <code>caret</code></a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="boosting.html"><a href="boosting.html"><i class="fa fa-check"></i><b>4.4</b> Boosting</a></li>
<li class="chapter" data-level="4.5" data-path="boosting-r.html"><a href="boosting-r.html"><i class="fa fa-check"></i><b>4.5</b> Boosting en R</a>
<ul>
<li class="chapter" data-level="4.5.1" data-path="boosting-r.html"><a href="boosting-r.html#ejemplo-clasificación-con-el-paquete-ada"><i class="fa fa-check"></i><b>4.5.1</b> Ejemplo: clasificación con el paquete <code>ada</code></a></li>
<li class="chapter" data-level="4.5.2" data-path="boosting-r.html"><a href="boosting-r.html#ejemplo-regresión-con-el-paquete-gbm"><i class="fa fa-check"></i><b>4.5.2</b> Ejemplo: regresión con el paquete <code>gbm</code></a></li>
<li class="chapter" data-level="4.5.3" data-path="boosting-r.html"><a href="boosting-r.html#xgb-caret"><i class="fa fa-check"></i><b>4.5.3</b> Ejemplo: XGBoost con el paquete <code>caret</code></a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="svm.html"><a href="svm.html"><i class="fa fa-check"></i><b>5</b> Máquinas de soporte vectorial</a>
<ul>
<li class="chapter" data-level="5.1" data-path="clasificadores-de-máximo-margen.html"><a href="clasificadores-de-máximo-margen.html"><i class="fa fa-check"></i><b>5.1</b> Clasificadores de máximo margen</a></li>
<li class="chapter" data-level="5.2" data-path="clasificadores-de-soporte-vectorial.html"><a href="clasificadores-de-soporte-vectorial.html"><i class="fa fa-check"></i><b>5.2</b> Clasificadores de soporte vectorial</a></li>
<li class="chapter" data-level="5.3" data-path="máquinas-de-soporte-vectorial.html"><a href="máquinas-de-soporte-vectorial.html"><i class="fa fa-check"></i><b>5.3</b> Máquinas de soporte vectorial</a>
<ul>
<li class="chapter" data-level="5.3.1" data-path="máquinas-de-soporte-vectorial.html"><a href="máquinas-de-soporte-vectorial.html#regresión-con-svm"><i class="fa fa-check"></i><b>5.3.1</b> Regresión con SVM</a></li>
<li class="chapter" data-level="5.3.2" data-path="máquinas-de-soporte-vectorial.html"><a href="máquinas-de-soporte-vectorial.html#ventajas-e-incovenientes"><i class="fa fa-check"></i><b>5.3.2</b> Ventajas e incovenientes</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="svm-kernlab.html"><a href="svm-kernlab.html"><i class="fa fa-check"></i><b>5.4</b> SVM en R</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="ext-glm.html"><a href="ext-glm.html"><i class="fa fa-check"></i><b>6</b> Extensiones de los modelos lineales (generalizados)</a>
<ul>
<li class="chapter" data-level="6.1" data-path="shrinkage.html"><a href="shrinkage.html"><i class="fa fa-check"></i><b>6.1</b> Métodos de regularización</a>
<ul>
<li class="chapter" data-level="6.1.1" data-path="shrinkage.html"><a href="shrinkage.html#implementación-en-r"><i class="fa fa-check"></i><b>6.1.1</b> Implementación en R</a></li>
<li class="chapter" data-level="6.1.2" data-path="shrinkage.html"><a href="shrinkage.html#ejemplo-ridge-regression"><i class="fa fa-check"></i><b>6.1.2</b> Ejemplo: <em>ridge regression</em></a></li>
<li class="chapter" data-level="6.1.3" data-path="shrinkage.html"><a href="shrinkage.html#ejemplo-lasso"><i class="fa fa-check"></i><b>6.1.3</b> Ejemplo: LASSO</a></li>
<li class="chapter" data-level="6.1.4" data-path="shrinkage.html"><a href="shrinkage.html#ejemplo-elastic-net"><i class="fa fa-check"></i><b>6.1.4</b> Ejemplo: <em>elastic net</em></a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="pca-pls.html"><a href="pca-pls.html"><i class="fa fa-check"></i><b>6.2</b> Métodos de reducción de la dimensión</a>
<ul>
<li class="chapter" data-level="6.2.1" data-path="pca-pls.html"><a href="pca-pls.html#regresión-por-componentes-principales-pcr"><i class="fa fa-check"></i><b>6.2.1</b> Regresión por componentes principales (PCR)</a></li>
<li class="chapter" data-level="6.2.2" data-path="pca-pls.html"><a href="pca-pls.html#regresión-por-mínimos-cuadrados-parciales-plsr"><i class="fa fa-check"></i><b>6.2.2</b> Regresión por mínimos cuadrados parciales (PLSR)</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="reg-np.html"><a href="reg-np.html"><i class="fa fa-check"></i><b>7</b> Regresión no paramétrica</a>
<ul>
<li class="chapter" data-level="7.1" data-path="reg-local.html"><a href="reg-local.html"><i class="fa fa-check"></i><b>7.1</b> Regresión local</a>
<ul>
<li class="chapter" data-level="7.1.1" data-path="reg-local.html"><a href="reg-local.html#reg-knn"><i class="fa fa-check"></i><b>7.1.1</b> Vecinos más próximos</a></li>
<li class="chapter" data-level="7.1.2" data-path="reg-local.html"><a href="reg-local.html#reg-locpol"><i class="fa fa-check"></i><b>7.1.2</b> Regresión polinómica local</a></li>
<li class="chapter" data-level="7.1.3" data-path="reg-local.html"><a href="reg-local.html#regresión-polinómica-local-robusta"><i class="fa fa-check"></i><b>7.1.3</b> Regresión polinómica local robusta</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="splines.html"><a href="splines.html"><i class="fa fa-check"></i><b>7.2</b> Splines</a>
<ul>
<li class="chapter" data-level="7.2.1" data-path="splines.html"><a href="splines.html#reg-splines"><i class="fa fa-check"></i><b>7.2.1</b> Splines de regresión</a></li>
<li class="chapter" data-level="7.2.2" data-path="splines.html"><a href="splines.html#splines-de-suavizado"><i class="fa fa-check"></i><b>7.2.2</b> Splines de suavizado</a></li>
<li class="chapter" data-level="7.2.3" data-path="splines.html"><a href="splines.html#splines-penalizados"><i class="fa fa-check"></i><b>7.2.3</b> Splines penalizados</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="reg-gam.html"><a href="reg-gam.html"><i class="fa fa-check"></i><b>7.3</b> Modelos aditivos</a>
<ul>
<li class="chapter" data-level="7.3.1" data-path="reg-gam.html"><a href="reg-gam.html#superficies-de-predicción"><i class="fa fa-check"></i><b>7.3.1</b> Superficies de predicción</a></li>
<li class="chapter" data-level="7.3.2" data-path="reg-gam.html"><a href="reg-gam.html#anova-gam"><i class="fa fa-check"></i><b>7.3.2</b> Comparación y selección de modelos</a></li>
<li class="chapter" data-level="7.3.3" data-path="reg-gam.html"><a href="reg-gam.html#mgcv-diagnosis"><i class="fa fa-check"></i><b>7.3.3</b> Diagnosis del modelo</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="mars.html"><a href="mars.html"><i class="fa fa-check"></i><b>7.4</b> Regresión spline adaptativa multivariante</a>
<ul>
<li class="chapter" data-level="7.4.1" data-path="mars.html"><a href="mars.html#mars-con-el-paquete-earth"><i class="fa fa-check"></i><b>7.4.1</b> MARS con el paquete <code>earth</code></a></li>
<li class="chapter" data-level="7.4.2" data-path="mars.html"><a href="mars.html#mars-con-el-paquete-caret"><i class="fa fa-check"></i><b>7.4.2</b> MARS con el paquete <code>caret</code></a></li>
</ul></li>
<li class="chapter" data-level="7.5" data-path="pursuit.html"><a href="pursuit.html"><i class="fa fa-check"></i><b>7.5</b> Projection pursuit</a>
<ul>
<li class="chapter" data-level="7.5.1" data-path="pursuit.html"><a href="pursuit.html#ppr"><i class="fa fa-check"></i><b>7.5.1</b> Regresión por projection pursuit</a></li>
<li class="chapter" data-level="7.5.2" data-path="pursuit.html"><a href="pursuit.html#implementación-en-r-1"><i class="fa fa-check"></i><b>7.5.2</b> Implementación en R</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="neural-nets.html"><a href="neural-nets.html"><i class="fa fa-check"></i><b>8</b> Redes neuronales</a>
<ul>
<li class="chapter" data-level="8.1" data-path="single-hidden-layer-feedforward-network.html"><a href="single-hidden-layer-feedforward-network.html"><i class="fa fa-check"></i><b>8.1</b> Single-hidden-layer feedforward network</a></li>
<li class="chapter" data-level="8.2" data-path="clasificación-con-ann.html"><a href="clasificación-con-ann.html"><i class="fa fa-check"></i><b>8.2</b> Clasificación con ANN</a></li>
<li class="chapter" data-level="8.3" data-path="implementación-en-r-2.html"><a href="implementación-en-r-2.html"><i class="fa fa-check"></i><b>8.3</b> Implementación en R</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="bibliografía.html"><a href="bibliografía.html"><i class="fa fa-check"></i>Bibliografía</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Métodos predictivos de aprendizaje estadístico</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="pca-pls" class="section level2 hasAnchor" number="6.2">
<h2><span class="header-section-number">6.2</span> Métodos de reducción de la dimensión<a href="pca-pls.html#pca-pls" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Otra alternativa, para tratar de reducir la varianza de los modelos lineales, es transformar los predictores considerando <span class="math inline">\(k &lt; p\)</span> combinaciones lineales:
<span class="math display">\[Z_j = a_{1j}X_{1} + a_{2j}X_{2} + \ldots + a_{pj}X_{p}\]</span>
con <span class="math inline">\(j = 1, \ldots, k\)</span>, denominadas componentes (o variables latentes),
y posteriormente ajustar un modelo de regresión lineal empleándolas como nuevos predictores:
<span class="math display">\[Y = \alpha_0 + \alpha_1 Z_1 + \ldots + \alpha_k Z_k + \varepsilon\]</span></p>
<p>Adicionalmente, si se seleccionan los coeficientes <span class="math inline">\(a_{ij}\)</span> (denominados <em>cargas</em> o <em>pesos</em>) de forma que
<span class="math display">\[\sum_{i=1}^p a_{ij}a_{il} = 0, \text{ si } j \neq l,\]</span>
las componentes serán ortogonales y se evitarán posibles problemas de colinealidad.
De esta forma se reduce la dimensión del problema, pasando de <span class="math inline">\(p + 1\)</span> a <span class="math inline">\(k + 1\)</span> coeficientes a estimar, lo cual en principio disminuirá la varianza, especialmente si <span class="math inline">\(p\)</span> es grande en comparación con <span class="math inline">\(n\)</span>.
Por otra parte, también podríamos expresar el modelo final en función de los predictores originales, con coeficientes:
<span class="math display">\[\beta_i = \sum_{j=1}^k \alpha_j a_{ij}\]</span>
Es decir, se ajusta un modelo lineal con restricciones, lo que en principio incrementará el sesgo (si <span class="math inline">\(k = p\)</span> sería equivalente a ajustar un modelo lineal sin restricciones).
Además, podríamos interpretar los coeficientes <span class="math inline">\(\alpha_j\)</span> como los efectos de las componentes del modo tradicional, pero resultaría más complicado interpretar los efectos de los predictores originales.</p>
<p>También hay que tener en cuenta que al considerar combinaciones lineales, si las hipótesis estructurales de linealidad, homocedasticidad, normalidad o independencia no son asumibles en el modelo original, es de esperar que tampoco lo sean en el modelo transformado (se podrían emplear las herramientas descritas en la Sección <a href="rlm.html#analisis-rlm">2.1.3</a> para su análisis).</p>
<p>Hay una gran variedad de algoritmos para obtener estas componentes. En esta sección consideraremos las dos aproximaciones más utilizadas: componentes principales y mínimos cuadrados parciales.
También hay numerosos paquetes de R que implementan métodos de este tipo (<a href="https://mevik.net/work/software/pls.html"><code>pls</code></a>, <a href="https://github.com/fbertran/plsRglm"><code>plsRglm</code></a>…), incluyendo <code>caret</code>.</p>
<div id="regresión-por-componentes-principales-pcr" class="section level3 hasAnchor" number="6.2.1">
<h3><span class="header-section-number">6.2.1</span> Regresión por componentes principales (PCR)<a href="pca-pls.html#regresión-por-componentes-principales-pcr" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Una de las aproximaciones tradicionales, cuando se detecta la presencia de colinealidad, consiste en aplicar el método de componentes principales a los predictores.
El análisis de componentes principales (<em>principal component analysis</em>, PCA) es un método muy utilizado de aprendizaje no supervisado, que permite reducir el número de dimensiones tratando de recoger la mayor parte de la variabilidad de los datos originales, en este caso de los predictores <span class="citation">(para más detalles sobre PCA ver, por ejemplo, el Capítulo 10 de <a href="#ref-james2021introduction" role="doc-biblioref">James et al., 2021</a>)</span>.</p>
<p>Al aplicar PCA a los predictores <span class="math inline">\(X_1, \ldots, X_p\)</span> se obtienen componentes ordenadas según la variabilidad explicada de forma descendente.
La primera componente es la que recoge el mayor porcentaje de la variabilidad total (se corresponde con la dirección de mayor variación de las observaciones).
Las siguientes componentes se seleccionan entre las direcciones ortogonales a las anteriores y de forma que recojan la mayor parte de la variabilidad restante.
Además, estas componentes son normalizadas, de forma que:
<span class="math display">\[\sum_{i=1}^p a_{ij}^2 = 1\]</span>
(se busca una transformación lineal ortonormal).
En la práctica, esto puede llevarse a cabo de manera sencilla a partir de la descomposición espectral de la matriz de covarianzas muestrales, aunque normalmente se estandarizan previamente los datos (<em>i. e.</em> se emplea la matriz de correlaciones).
Por tanto, si se pretende emplear estas componentes para ajustar un modelo de regresión, habrá que conservar los parámetros de estas transformaciones para poder aplicarlas a nuevas observaciones.</p>
<p>Normalmente, se seleccionan las primeras <span class="math inline">\(k\)</span> componentes de forma que expliquen la mayor parte de la variabilidad de los datos (los predictores en este caso).
En PCR <span class="citation">(<em>principal component regression</em>, <a href="#ref-massy1965principal" role="doc-biblioref">Massy, 1965</a>)</span> se confía en que estas componentes recojan también la mayor parte de la información sobre la respuesta, pero podría no ser el caso.</p>
<p>Aunque se pueden utilizar las funciones <code>printcomp()</code> y <code>lm()</code> del paquete base, emplearemos por comodidad la función <a href="https://rdrr.io/pkg/pls/man/mvr.html"><code>pcr()</code></a> del paquete <a href="https://mevik.net/work/software/pls.html"><code>pls</code></a> <span class="citation">(<a href="#ref-Mevik2007pls" role="doc-biblioref">Mevik y Wehrens, 2007</a>)</span>, ya que incorpora validación cruzada para seleccionar el número de componentes y facilita el cálculo de nuevas predicciones.
Los argumentos principales de esta función son:</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb354-1"><a href="pca-pls.html#cb354-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pcr</span>(formula, ncomp, data, <span class="at">scale =</span> <span class="cn">FALSE</span>, <span class="at">center =</span> <span class="cn">TRUE</span>, </span>
<span id="cb354-2"><a href="pca-pls.html#cb354-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">validation =</span> <span class="fu">c</span>(<span class="st">&quot;none&quot;</span>, <span class="st">&quot;CV&quot;</span>, <span class="st">&quot;LOO&quot;</span>), <span class="at">segments =</span> <span class="dv">10</span>, </span>
<span id="cb354-3"><a href="pca-pls.html#cb354-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">segment.type =</span> <span class="fu">c</span>(<span class="st">&quot;random&quot;</span>, <span class="st">&quot;consecutive&quot;</span>, <span class="st">&quot;interleaved&quot;</span>), ...)</span></code></pre></div>
<ul>
<li><p><code>ncomp</code>: número máximo de componentes (ajustará modelos desde 1 hasta <code>ncomp</code> componentes).</p></li>
<li><p><code>scale</code>, <code>center</code>: normalmente valores lógicos indicando si los predictores serán reescalados (divididos por su desviación estándar y centrados, restando su media).</p></li>
<li><p><code>validation</code>: determina el tipo de validación, puede ser <code>"none"</code> (ninguna, se empleará el modelo ajustado con toda la muestra de entrenamiento), <code>"LOO"</code> (VC dejando uno fuera) y <code>"CV"</code> (VC por grupos). En este último caso, los grupos de validación se especifican mediante <code>segments</code> (número de grupos) y <code>segment.type</code> (por defecto aleatorios; para más detalles consultar la ayuda de <a href="https://rdrr.io/pkg/pls/man/mvrCv.html"><code>mvrCv()</code></a>).</p></li>
</ul>
<p>Como ejemplo continuaremos con los datos de grasa corporal.
Reescalaremos los predictores y emplearemos validación cruzada por grupos para seleccionar el número de componentes:</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb355-1"><a href="pca-pls.html#cb355-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(pls)</span>
<span id="cb355-2"><a href="pca-pls.html#cb355-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb355-3"><a href="pca-pls.html#cb355-3" aria-hidden="true" tabindex="-1"></a>pcreg <span class="ot">&lt;-</span> <span class="fu">pcr</span>(bodyfat <span class="sc">~</span> ., <span class="at">data =</span> train, <span class="at">scale =</span> <span class="cn">TRUE</span>, <span class="at">validation =</span> <span class="st">&quot;CV&quot;</span>)</span></code></pre></div>
<p>Podemos obtener un resumen de los resultados de validación (evolución de los errores de validación cruzada) y del ajuste en la muestra de entrenamiento (evolución de la proporción de variabilidad explicada de los predictores y de la respuesta) con el método <a href="https://rdrr.io/pkg/pls/man/summary.mvr.html"><code>summary()</code></a>:</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb356-1"><a href="pca-pls.html#cb356-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(pcreg)</span></code></pre></div>
<pre><code>## Data:    X dimension: 196 13 
##  Y dimension: 196 1
## Fit method: svdpc
## Number of components considered: 13
## 
## VALIDATION: RMSEP
## Cross-validated using 10 random segments.
##        (Intercept)  1 comps  2 comps  3 comps  4 comps  5 comps  6 comps
## CV           8.253    6.719    5.778    5.327    5.023    5.050    5.082
## adjCV        8.253    6.713    5.763    5.310    5.014    5.041    5.077
##        7 comps  8 comps  9 comps  10 comps  11 comps  12 comps  13 comps
## CV       4.935    4.887    4.899     4.881     4.929     4.449     4.457
## adjCV    4.907    4.873    4.887     4.870     4.925     4.436     4.444
## 
## TRAINING: % variance explained
##          1 comps  2 comps  3 comps  4 comps  5 comps  6 comps  7 comps  8 comps
## X          61.55    72.80    79.90    85.42    89.33    91.98    94.17    96.06
## bodyfat    35.51    53.27    59.62    64.52    64.53    64.58    67.25    67.33
##          9 comps  10 comps  11 comps  12 comps  13 comps
## X          97.63     98.76     99.37     99.85    100.00
## bodyfat    67.33     67.62     67.64     73.65     73.67</code></pre>
<p>Aunque suele resultar más cómodo representar gráficamente estos valores (ver Figura <a href="pca-pls.html#fig:pcreg-plot">6.6</a>).
Por ejemplo empleando <a href="https://rdrr.io/pkg/pls/man/mvrVal.html"><code>RMSEP()</code></a> para acceder a los errores de validación<a href="#fn56" class="footnote-ref" id="fnref56"><sup>56</sup></a>:</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb358-1"><a href="pca-pls.html#cb358-1" aria-hidden="true" tabindex="-1"></a><span class="co"># validationplot(pcreg, legend = &quot;topright&quot;) </span></span>
<span id="cb358-2"><a href="pca-pls.html#cb358-2" aria-hidden="true" tabindex="-1"></a>rmsep.cv <span class="ot">&lt;-</span> <span class="fu">RMSEP</span>(pcreg)</span>
<span id="cb358-3"><a href="pca-pls.html#cb358-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(rmsep.cv, <span class="at">legend =</span> <span class="st">&quot;topright&quot;</span>)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:pcreg-plot"></span>
<img src="06-ext_glm_files/figure-html/pcreg-plot-1.png" alt="Errores de validación cruzada en función del número de componentes en el ajuste mediante PCR." width="75%" />
<p class="caption">
Figura 6.6: Errores de validación cruzada en función del número de componentes en el ajuste mediante PCR.
</p>
</div>
<div class="sourceCode" id="cb359"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb359-1"><a href="pca-pls.html#cb359-1" aria-hidden="true" tabindex="-1"></a>ncomp.op <span class="ot">&lt;-</span> <span class="fu">with</span>(rmsep.cv, comps[<span class="fu">which.min</span>(val[<span class="dv">2</span>, <span class="dv">1</span>, ])]) <span class="co"># mínimo adjCV RMSEP</span></span></code></pre></div>
<p>En este caso, empleando el criterio de menor error de validación cruzada se seleccionaría un número elevado de componentes, el mínimo se alcanzaría con 12 componentes (casi como ajustar un modelo lineal con todos los predictores).</p>
<!-- biplot(pcreg) -->
<p>Los coeficientes de los predictores originales con el modelo seleccionado serían<a href="#fn57" class="footnote-ref" id="fnref57"><sup>57</sup></a>:</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb360-1"><a href="pca-pls.html#cb360-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(pcreg, <span class="at">ncomp =</span> <span class="dv">12</span>, <span class="at">intercept =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## , , 12 comps
## 
##               bodyfat
## (Intercept) 21.141410
## age          0.523514
## weight       0.730388
## height      -0.915070
## neck        -0.625323
## chest       -1.361064
## abdomen      9.175811
## hip         -1.587609
## thigh        0.576468
## knee         0.050425
## ankle       -0.025927
## biceps       0.422922
## forearm      0.595122
## wrist       -1.781728</code></pre>
<p>Finalmente evaluamos su precisión:</p>
<div class="sourceCode" id="cb362"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb362-1"><a href="pca-pls.html#cb362-1" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">&lt;-</span> <span class="fu">predict</span> (pcreg , test, <span class="at">ncomp =</span> <span class="dv">12</span>)</span>
<span id="cb362-2"><a href="pca-pls.html#cb362-2" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(pred, obs)</span></code></pre></div>
<pre><code>##        me      rmse       mae       mpe      mape r.squared 
##   1.46888   3.96040   3.24888   1.40161  18.71800   0.75754</code></pre>
<p>Alternativamente, podríamos emplear el método <code>"pcr"</code> de <code>caret</code>.
Por ejemplo, seleccionando el número de componentes mediante la regla de un error estándar (ver Figura <a href="pca-pls.html#fig:pcr-plot-caret">6.7</a>):</p>
<div class="sourceCode" id="cb364"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb364-1"><a href="pca-pls.html#cb364-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(caret)</span>
<span id="cb364-2"><a href="pca-pls.html#cb364-2" aria-hidden="true" tabindex="-1"></a><span class="fu">modelLookup</span>(<span class="st">&quot;pcr&quot;</span>)</span></code></pre></div>
<pre><code>##   model parameter       label forReg forClass probModel
## 1   pcr     ncomp #Components   TRUE    FALSE     FALSE</code></pre>
<div class="sourceCode" id="cb366"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb366-1"><a href="pca-pls.html#cb366-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb366-2"><a href="pca-pls.html#cb366-2" aria-hidden="true" tabindex="-1"></a>trControl <span class="ot">&lt;-</span> <span class="fu">trainControl</span>(<span class="at">method =</span> <span class="st">&quot;cv&quot;</span>, <span class="at">number =</span> <span class="dv">10</span>, </span>
<span id="cb366-3"><a href="pca-pls.html#cb366-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">selectionFunction =</span> <span class="st">&quot;oneSE&quot;</span>)</span>
<span id="cb366-4"><a href="pca-pls.html#cb366-4" aria-hidden="true" tabindex="-1"></a>caret.pcr <span class="ot">&lt;-</span> <span class="fu">train</span>(bodyfat <span class="sc">~</span> ., <span class="at">data =</span> train, <span class="at">method =</span> <span class="st">&quot;pcr&quot;</span>,</span>
<span id="cb366-5"><a href="pca-pls.html#cb366-5" aria-hidden="true" tabindex="-1"></a>                   <span class="at">preProcess =</span> <span class="fu">c</span>(<span class="st">&quot;zv&quot;</span>, <span class="st">&quot;center&quot;</span>, <span class="st">&quot;scale&quot;</span>), </span>
<span id="cb366-6"><a href="pca-pls.html#cb366-6" aria-hidden="true" tabindex="-1"></a>                   <span class="at">trControl =</span> trControl, <span class="at">tuneGrid =</span> <span class="fu">data.frame</span>(<span class="at">ncomp =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>))</span>
<span id="cb366-7"><a href="pca-pls.html#cb366-7" aria-hidden="true" tabindex="-1"></a>caret.pcr</span></code></pre></div>
<pre><code>## Principal Component Analysis 
## 
## 196 samples
##  13 predictor
## 
## Pre-processing: centered (13), scaled (13) 
## Resampling: Cross-Validated (10 fold) 
## Summary of sample sizes: 177, 176, 176, 177, 177, 177, ... 
## Resampling results across tuning parameters:
## 
##   ncomp  RMSE    Rsquared  MAE   
##    1     6.5808  0.36560   5.3235
##    2     5.6758  0.53027   4.7039
##    3     5.2136  0.59429   4.3556
##    4     4.9757  0.62975   4.0940
##    5     5.0257  0.62283   4.1352
##    6     5.1269  0.60878   4.2177
##    7     4.9522  0.62418   4.0541
##    8     4.9588  0.62119   4.0375
##    9     4.9612  0.61994   4.0361
##   10     4.9603  0.61727   4.0152
## 
## RMSE was used to select the optimal model using  the one SE rule.
## The final value used for the model was ncomp = 3.</code></pre>
<div class="sourceCode" id="cb368"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb368-1"><a href="pca-pls.html#cb368-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(caret.pcr, <span class="at">highlight =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:pcr-plot-caret"></span>
<img src="06-ext_glm_files/figure-html/pcr-plot-caret-1.png" alt="Errores de validación cruzada en función del número de componentes en el ajuste mediante PCR y valor óptimo según la regla de un error estándar." width="75%" />
<p class="caption">
Figura 6.7: Errores de validación cruzada en función del número de componentes en el ajuste mediante PCR y valor óptimo según la regla de un error estándar.
</p>
</div>
<div class="sourceCode" id="cb369"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb369-1"><a href="pca-pls.html#cb369-1" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(caret.pcr, <span class="at">newdata =</span> test)</span>
<span id="cb369-2"><a href="pca-pls.html#cb369-2" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(pred, obs)</span></code></pre></div>
<pre><code>##        me      rmse       mae       mpe      mape r.squared 
##   1.21285   5.20850   4.33211  -5.71168  28.14310   0.58064</code></pre>
<p>Al incluir más componentes se aumenta la proporción de variabilidad explicada de los predictores,
pero esto no está relacionado con su utilidad para explicar la respuesta.
No va a haber problemas de colinealidad aunque incluyamos muchas componentes, pero se tendrán que estimar más coeficientes y va a disminuir su precisión.
Sería más razonable obtener las componentes principales y después aplicar un método de selección.
Por ejemplo, podemos combinar el método de preprocesado <code>"pca"</code> de <code>caret</code> con un método de selección de variables<a href="#fn58" class="footnote-ref" id="fnref58"><sup>58</sup></a> (ver Figura <a href="pca-pls.html#fig:pcr2-plot-caret">6.8</a>):</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb371-1"><a href="pca-pls.html#cb371-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb371-2"><a href="pca-pls.html#cb371-2" aria-hidden="true" tabindex="-1"></a>caret.pcrsel <span class="ot">&lt;-</span> <span class="fu">train</span>(bodyfat <span class="sc">~</span> ., <span class="at">data =</span> train, <span class="at">method =</span> <span class="st">&quot;leapSeq&quot;</span>,</span>
<span id="cb371-3"><a href="pca-pls.html#cb371-3" aria-hidden="true" tabindex="-1"></a>                    <span class="at">preProcess =</span> <span class="fu">c</span>(<span class="st">&quot;zv&quot;</span>, <span class="st">&quot;center&quot;</span>, <span class="st">&quot;scale&quot;</span>, <span class="st">&quot;pca&quot;</span>),     </span>
<span id="cb371-4"><a href="pca-pls.html#cb371-4" aria-hidden="true" tabindex="-1"></a>                    <span class="at">trControl =</span> trControl, <span class="at">tuneGrid =</span> <span class="fu">data.frame</span>(<span class="at">nvmax =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>))</span>
<span id="cb371-5"><a href="pca-pls.html#cb371-5" aria-hidden="true" tabindex="-1"></a>caret.pcrsel</span></code></pre></div>
<pre><code>## Linear Regression with Stepwise Selection 
## 
## 196 samples
##  13 predictor
## 
## Pre-processing: centered (13), scaled (13), principal component
##  signal extraction (13) 
## Resampling: Cross-Validated (10 fold) 
## Summary of sample sizes: 177, 176, 176, 177, 177, 177, ... 
## Resampling results across tuning parameters:
## 
##   nvmax  RMSE    Rsquared  MAE   
##   1      6.5808  0.36560   5.3235
##   2      5.6758  0.53027   4.7039
##   3      5.4083  0.57633   4.4092
##   4      5.0320  0.62265   4.1378
##   5      4.8434  0.64078   3.9361
##   6      4.9449  0.62511   4.0321
## 
## RMSE was used to select the optimal model using  the one SE rule.
## The final value used for the model was nvmax = 4.</code></pre>
<div class="sourceCode" id="cb373"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb373-1"><a href="pca-pls.html#cb373-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(caret.pcrsel, <span class="at">highlight =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:pcr2-plot-caret"></span>
<img src="06-ext_glm_files/figure-html/pcr2-plot-caret-1.png" alt="Errores de validación cruzada en función del número de componentes en el ajuste mediante PCR con selección por pasos y valor óptimo según la regla de un error estándar." width="70%" />
<p class="caption">
Figura 6.8: Errores de validación cruzada en función del número de componentes en el ajuste mediante PCR con selección por pasos y valor óptimo según la regla de un error estándar.
</p>
</div>
<p>No obstante, en este caso las primeras componentes también resultan ser aparentemente las de mayor utilidad para explicar la respuesta, ya que se seleccionaron las cuatro primeras:</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb374-1"><a href="pca-pls.html#cb374-1" aria-hidden="true" tabindex="-1"></a><span class="fu">with</span>(caret.pcrsel, <span class="fu">coef</span>(finalModel, bestTune<span class="sc">$</span>nvmax))</span></code></pre></div>
<pre><code>## (Intercept)         PC1         PC2         PC3         PC4 
##     18.8036      1.7341     -2.8685      2.1570     -2.1531</code></pre>
<p>Para finalizar evaluamos también la precisión del modelo obtenido:</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb376-1"><a href="pca-pls.html#cb376-1" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(caret.pcrsel, <span class="at">newdata =</span> test)</span>
<span id="cb376-2"><a href="pca-pls.html#cb376-2" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(pred, obs)</span></code></pre></div>
<pre><code>##        me      rmse       mae       mpe      mape r.squared 
##   0.83749   4.76899   3.89344  -6.10279  25.16598   0.64843</code></pre>
<!-- 
Pendiente: revisar error con nvmax = 1:10
-->
</div>
<div id="regresión-por-mínimos-cuadrados-parciales-plsr" class="section level3 hasAnchor" number="6.2.2">
<h3><span class="header-section-number">6.2.2</span> Regresión por mínimos cuadrados parciales (PLSR)<a href="pca-pls.html#regresión-por-mínimos-cuadrados-parciales-plsr" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Como ya se comentó, en PCR las componentes se determinan con el objetivo de explicar la variabilidad de los predictores, ignorando por completo la respuesta.
Por el contrario, en PLSR <span class="citation">(<em>partial least squares regression</em>, <a href="#ref-wold1983multivariate" role="doc-biblioref">Wold et al., 1983</a>)</span> se construyen las componentes <span class="math inline">\(Z_1, \ldots, Z_k\)</span> teniendo en cuenta desde un principio el objetivo final de predecir linealmente la respuesta.</p>
<p>Hay varios procedimientos para seleccionar los pesos <span class="math inline">\(a_{ij}\)</span>, pero la idea es asignar mayor peso a los predictores que están más correlacionados con la respuesta (o con los correspondientes residuos al ir obteniendo nuevas componentes), considerando siempre direcciones ortogonales <span class="citation">(ver, por ejemplo, la Sección 6.3.2 de <a href="#ref-james2021introduction" role="doc-biblioref">James et al., 2021</a>)</span>.</p>
<p>Continuando con el ejemplo anterior, emplearemos en primer lugar la función <a href="https://rdrr.io/pkg/pls/man/mvr.html"><code>plsr()</code></a> del paquete <a href="https://mevik.net/work/software/pls.html"><code>pls</code></a>, que tiene los mismos argumentos que la función <code>pcr()</code> descrita en la sección anterior<a href="#fn59" class="footnote-ref" id="fnref59"><sup>59</sup></a>:</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb378-1"><a href="pca-pls.html#cb378-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb378-2"><a href="pca-pls.html#cb378-2" aria-hidden="true" tabindex="-1"></a>plsreg <span class="ot">&lt;-</span> <span class="fu">plsr</span>(bodyfat <span class="sc">~</span> ., <span class="at">data =</span> train, <span class="at">scale =</span> <span class="cn">TRUE</span>, <span class="at">validation =</span> <span class="st">&quot;CV&quot;</span>)</span>
<span id="cb378-3"><a href="pca-pls.html#cb378-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(plsreg)</span></code></pre></div>
<pre><code>## Data:    X dimension: 196 13 
##  Y dimension: 196 1
## Fit method: kernelpls
## Number of components considered: 13
## 
## VALIDATION: RMSEP
## Cross-validated using 10 random segments.
##        (Intercept)  1 comps  2 comps  3 comps  4 comps  5 comps  6 comps
## CV           8.253    6.279    4.969    4.809    4.652    4.550    4.474
## adjCV        8.253    6.273    4.965    4.798    4.637    4.541    4.458
##        7 comps  8 comps  9 comps  10 comps  11 comps  12 comps  13 comps
## CV       4.466    4.451    4.454     4.455     4.455     4.456     4.457
## adjCV    4.452    4.438    4.442     4.442     4.442     4.443     4.444
## 
## TRAINING: % variance explained
##          1 comps  2 comps  3 comps  4 comps  5 comps  6 comps  7 comps
## X          60.53     71.8    78.48    81.90    86.35    88.12    90.16
## bodyfat    44.34     65.1    68.47    71.07    72.35    73.62    73.66
##          8 comps  9 comps  10 comps  11 comps  12 comps  13 comps
## X          92.96    95.50     96.51     97.82     98.44    100.00
## bodyfat    73.67    73.67     73.67     73.67     73.67     73.67</code></pre>
<div class="sourceCode" id="cb380"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb380-1"><a href="pca-pls.html#cb380-1" aria-hidden="true" tabindex="-1"></a><span class="co"># validationplot(plsreg, legend = &quot;topright&quot;)</span></span>
<span id="cb380-2"><a href="pca-pls.html#cb380-2" aria-hidden="true" tabindex="-1"></a>rmsep.cv <span class="ot">&lt;-</span> <span class="fu">RMSEP</span>(plsreg)</span>
<span id="cb380-3"><a href="pca-pls.html#cb380-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(rmsep.cv, <span class="at">legend =</span> <span class="st">&quot;topright&quot;</span>)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:plsr-plot"></span>
<img src="06-ext_glm_files/figure-html/plsr-plot-1.png" alt="Error cuadrático medio de validación cruzada en función del número de componentes en el ajuste mediante PLS." width="75%" />
<p class="caption">
Figura 6.9: Error cuadrático medio de validación cruzada en función del número de componentes en el ajuste mediante PLS.
</p>
</div>
<div class="sourceCode" id="cb381"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb381-1"><a href="pca-pls.html#cb381-1" aria-hidden="true" tabindex="-1"></a>ncomp.op <span class="ot">&lt;-</span> <span class="fu">with</span>(rmsep.cv, comps[<span class="fu">which.min</span>(val[<span class="dv">2</span>, <span class="dv">1</span>, ])]) <span class="co"># mínimo adjCV RMSEP</span></span></code></pre></div>
<p>En este caso el mínimo se alcanza con 8 componentes, pero, a la vista de la Figura <a href="pca-pls.html#fig:plsr-plot">6.9</a>, parece que 6 (o incluso 2) sería un valor más razonable.
Podemos obtener los coeficientes de los predictores del modelo seleccionado:</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb382-1"><a href="pca-pls.html#cb382-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(plsreg, <span class="at">ncomp =</span> <span class="dv">6</span>, <span class="at">intercept =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## , , 6 comps
## 
##              bodyfat
## (Intercept) 16.54393
## age          0.63007
## weight       0.42119
## height      -0.82098
## neck        -0.55223
## chest       -1.37545
## abdomen      9.14806
## hip         -1.27990
## thigh        0.76228
## knee        -0.23770
## ankle        0.08447
## biceps       0.40080
## forearm      0.60030
## wrist       -1.80885</code></pre>
<p>y evaluar su precisión:</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb384-1"><a href="pca-pls.html#cb384-1" aria-hidden="true" tabindex="-1"></a>pred.pls <span class="ot">&lt;-</span> <span class="fu">predict</span>(plsreg , test, <span class="at">ncomp =</span> <span class="dv">6</span>)</span>
<span id="cb384-2"><a href="pca-pls.html#cb384-2" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(pred.pls, obs)</span></code></pre></div>
<pre><code>##        me      rmse       mae       mpe      mape r.squared 
##    1.4373    3.9255    3.2329    1.2006   18.7601    0.7618</code></pre>
<p>Empleamos también el método <code>"pls"</code> de <code>caret</code> seleccionando el número de componentes mediante la regla de un error estándar (ver Figura <a href="pca-pls.html#fig:plsr-plot-caret">6.10</a>):</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb386-1"><a href="pca-pls.html#cb386-1" aria-hidden="true" tabindex="-1"></a><span class="fu">modelLookup</span>(<span class="st">&quot;pls&quot;</span>)</span></code></pre></div>
<pre><code>##   model parameter       label forReg forClass probModel
## 1   pls     ncomp #Components   TRUE     TRUE      TRUE</code></pre>
<div class="sourceCode" id="cb388"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb388-1"><a href="pca-pls.html#cb388-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb388-2"><a href="pca-pls.html#cb388-2" aria-hidden="true" tabindex="-1"></a>caret.pls <span class="ot">&lt;-</span> <span class="fu">train</span>(bodyfat <span class="sc">~</span> ., <span class="at">data =</span> train, <span class="at">method =</span> <span class="st">&quot;pls&quot;</span>,</span>
<span id="cb388-3"><a href="pca-pls.html#cb388-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">preProcess =</span> <span class="fu">c</span>(<span class="st">&quot;zv&quot;</span>, <span class="st">&quot;center&quot;</span>, <span class="st">&quot;scale&quot;</span>),</span>
<span id="cb388-4"><a href="pca-pls.html#cb388-4" aria-hidden="true" tabindex="-1"></a>                   <span class="at">trControl =</span> trControl, <span class="at">tuneGrid =</span> <span class="fu">data.frame</span>(<span class="at">ncomp =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>))</span>
<span id="cb388-5"><a href="pca-pls.html#cb388-5" aria-hidden="true" tabindex="-1"></a>caret.pls</span></code></pre></div>
<pre><code>## Partial Least Squares 
## 
## 196 samples
##  13 predictor
## 
## Pre-processing: centered (13), scaled (13) 
## Resampling: Cross-Validated (10 fold) 
## Summary of sample sizes: 177, 176, 176, 177, 177, 177, ... 
## Resampling results across tuning parameters:
## 
##   ncomp  RMSE    Rsquared  MAE   
##    1     6.1572  0.44386   4.9987
##    2     4.9669  0.63414   4.1385
##    3     4.8262  0.64034   3.9733
##    4     4.7833  0.64563   3.9540
##    5     4.6810  0.66197   3.8776
##    6     4.5704  0.68981   3.7961
##    7     4.5855  0.68780   3.8110
##    8     4.5613  0.69161   3.7855
##    9     4.5566  0.69237   3.7800
##   10     4.5671  0.69087   3.7897
## 
## RMSE was used to select the optimal model using  the one SE rule.
## The final value used for the model was ncomp = 5.</code></pre>
<div class="sourceCode" id="cb390"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb390-1"><a href="pca-pls.html#cb390-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(caret.pls, <span class="at">highlight =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:plsr-plot-caret"></span>
<img src="06-ext_glm_files/figure-html/plsr-plot-caret-1.png" alt="Errores de validación cruzada en función del número de componentes en el ajuste mediante PLS." width="70%" />
<p class="caption">
Figura 6.10: Errores de validación cruzada en función del número de componentes en el ajuste mediante PLS.
</p>
</div>
<div class="sourceCode" id="cb391"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb391-1"><a href="pca-pls.html#cb391-1" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(caret.pls, <span class="at">newdata =</span> test)</span>
<span id="cb391-2"><a href="pca-pls.html#cb391-2" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(pred, obs)</span></code></pre></div>
<pre><code>##        me      rmse       mae       mpe      mape r.squared 
##   1.58389   4.14455   3.50307   0.82895  20.26616   0.73447</code></pre>
<p>En la práctica se suelen obtener resultados muy similares empleando PCR, PLSR o <em>ridge regression</em>.
Todos ellos son modelos lineales, por lo que el principal problema es que no sean suficientemente flexibles para explicar adecuadamente lo que ocurre con los datos (puede que no sea adecuado asumir que el efecto de algún predictor es lineal).
En este problema concreto, el mejor resultado se obtuvo con el ajuste con <code>plsr()</code>, aunque si representamos las observaciones frente a las predicciones (ver Figura <a href="pca-pls.html#fig:plsr-test">6.11</a>):</p>

<div class="sourceCode" id="cb393"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb393-1"><a href="pca-pls.html#cb393-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pred.plot</span>(pred.pls, obs, <span class="at">xlab =</span> <span class="st">&quot;Predicción&quot;</span>, <span class="at">ylab =</span> <span class="st">&quot;Observado&quot;</span>)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:plsr-test"></span>
<img src="06-ext_glm_files/figure-html/plsr-test-1.png" alt="Gráfico de dispersión de observaciones frente a predicciones, del ajuste lineal con plsr(), en la muestra de test." width="75%" />
<p class="caption">
Figura 6.11: Gráfico de dispersión de observaciones frente a predicciones, del ajuste lineal con <code>plsr()</code>, en la muestra de test.
</p>
</div>
<p>parece que se debería haber incluido un término cuadrático (coincidiendo con lo observado en las secciones <a href="rlm.html#analisis-rlm">2.1.3</a> y <a href="rlm.html#eval-rlm">2.1.4</a>).</p>
<p>Como comentarios finales, el método PCR (Sección <a href="pca-pls.html#pca-pls">6.2</a>) se extiende de forma inmediata al caso de modelos generalizados, simplemente cambiando el tipo de modelo ajustado.
También están disponibles métodos PLSR para modelos generalizados <span class="citation">(p. ej. paquete <a href="https://fbertran.github.io/plsRglm" role="doc-biblioref"><code>plsRglm</code></a>, <a href="#ref-R-plsRglm" role="doc-biblioref">Bertrand y Maumy, 2023</a>)</span>.
En cualquier caso, <code>caret</code> ajustará un modelo generalizado si la respuesta es un factor.</p>
<div class="exercise">
<p><span id="exr:bfan-pca-pls" class="exercise"><strong>Ejercicio 6.2  </strong></span>Continuando con el Ejercicio <a href="shrinkage.html#exr:bfan-glmnet">6.1</a> y utilizando la misma partición, vuelve a clasificar los individuos según su nivel de grasa corporal (<code>bfan</code>), pero ahora:</p>
<ol style="list-style-type: lower-alpha">
<li><p>Ajusta un modelo de regresión logística por componentes principales, con el método <code>"glmStepAIC"</code> de <code>caret</code> y preprocesado <code>"pca"</code>.</p></li>
<li><p>Ajusta un modelo de regresión logística por mínimos cuadrados parciales con el método <code>"pls"</code> de <code>caret</code>.</p></li>
<li><p>Interpreta los modelos obtenidos, evalúa la capacidad predictiva en la muestra <code>test</code> y compara los resultados (también con los del Ejercicio <a href="shrinkage.html#exr:bfan-glmnet">6.1</a>).</p></li>
</ol>
</div>

</div>
</div>
<!-- </div> -->
<h3>Bibliografía<a href="bibliografía.html#bibliografía" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div id="refs" class="references csl-bib-body hanging-indent" line-spacing="2">
<div id="ref-R-plsRglm" class="csl-entry">
Bertrand, F., y Maumy, M. (2023). <em>Partial Least Squares Regression for Generalized Linear Models</em>. manual. <a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</div>
<div id="ref-james2021introduction" class="csl-entry">
James, G., Witten, D., Hastie, T., y Tibshirani, R. (2021). <em>An Introduction to Statistical Learning: With Applications in R</em> (2a. ed.). Springer. <a href="https://www.statlearning.com" class="uri">https://www.statlearning.com</a>. <a href="https://www.statlearning.com">https://www.statlearning.com</a>
</div>
<div id="ref-massy1965principal" class="csl-entry">
Massy, W. F. (1965). Principal components regression in exploratory statistical research. <em>Journal of the American Statistical Association</em>, <em>60</em>(309), 234-256. <a href="https://doi.org/10.1080/01621459.1965.10480787">https://doi.org/10.1080/01621459.1965.10480787</a>
</div>
<div id="ref-Mevik2007pls" class="csl-entry">
Mevik, B.-H., y Wehrens, R. (2007). The pls Package: Principal Component and Partial Least Squares Regression in <span>R</span>. <em>Journal of Statistical Software</em>, <em>18</em>(2), 1-23. <a href="https://doi.org/10.18637/jss.v018.i02">https://doi.org/10.18637/jss.v018.i02</a>
</div>
<div id="ref-wold1983multivariate" class="csl-entry">
Wold, S., Martens, H., y Wold, H. (1983). The multivariate calibration problem in chemistry solved by the <span>PLS</span> method. En <em>Matrix pencils</em> (pp. 286-293). Springer. <a href="https://doi.org/10.1007/bfb0062108">https://doi.org/10.1007/bfb0062108</a>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="56">
<li id="fn56"><p><code>"adjCV"</code> es una estimación de validación cruzada con corrección de sesgo.<a href="pca-pls.html#fnref56" class="footnote-back">↩︎</a></p></li>
<li id="fn57"><p>También se pueden analizar distintos aspectos del ajuste (predicciones, coeficientes, puntuaciones, cargas, biplots, cargas de correlación o gráficos de validación) con el método <a href="https://rdrr.io/pkg/pls/man/plot.mvr.html"><code>plot.mvr()</code></a>.<a href="pca-pls.html#fnref57" class="footnote-back">↩︎</a></p></li>
<li id="fn58"><p>Esta forma de proceder se podría emplear con otros modelos que puedan tener problemas de colinealidad, como los lineales generalizados.<a href="pca-pls.html#fnref58" class="footnote-back">↩︎</a></p></li>
<li id="fn59"><p>Realmente, ambas funciones llaman internamente a <a href="https://rdrr.io/pkg/pls/man/mvr.html"><code>mvr()</code></a>, donde están implementadas distintas proyecciones <span class="citation">(ver <a href="https://rdrr.io/pkg/pls/man/pls.options.html" role="doc-biblioref"><code>help(pls.options)</code></a>, o <a href="#ref-Mevik2007pls" role="doc-biblioref">Mevik y Wehrens, 2007</a>)</span>.<a href="pca-pls.html#fnref59" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="shrinkage.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="reg-np.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rubenfcasal/book_mpae/edit/master/06-ext_glm.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["book_mpae.pdf"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
